package ru.neoflex.ndk.dsl.declaration

import ru.neoflex.ndk.dsl.Gateway.{ SealedWhens, When, WhenBuilder }
import ru.neoflex.ndk.dsl.Rule.{ Condition, ConditionBuilder, Otherwise, RuleBuilder }
import ru.neoflex.ndk.dsl._

object NdkInternals {
  val ClassNames: Set[String] = Seq(
    classOf[Action],
    classOf[ActionBase],
    classOf[ActionSyntax],
    classOf[SealedAction],
    classOf[DeclarationLocation],
    DeclarationLocation.getClass,
    classOf[DeclarationLocationSupport],
    NdkInternals.getClass,
    classOf[Constants],
    classOf[FlowOp],
    classOf[RuleOp],
    classOf[Flow],
    classOf[SealedFlow],
    classOf[TableOp],
    classOf[GatewayOp],
    classOf[WhileOp],
    classOf[ForEachOp],
    classOf[FlowSyntax],
    classOf[Gateway],
    classOf[When],
    classOf[SealedWhens],
    classOf[WhenBuilder],
    classOf[GatewaySyntax],
    classOf[ImplicitConversions],
    implicits.getClass,
    classOf[Table],
    classOf[Table.TableBuilder],
    classOf[Table.Expression],
    classOf[Table.ActionDef],
    classOf[Table.Condition],
    classOf[SealedTable],
    classOf[Table.Action0],
    classOf[Table.Action1],
    classOf[Table.Action2],
    classOf[Table.Action3],
    classOf[Table.Action4],
    classOf[Table.Action5],
    classOf[Table.Action6],
    classOf[Table.Action7],
    classOf[Table.Action8],
    classOf[Table.Action9],
    classOf[Table.Action10],
    classOf[Table.Args],
    classOf[Table.CallableAction],
    classOf[Table.ActionRef],
    classOf[Table.SealedAction],
    classOf[Table.Operator],
    classOf[Table.RowBuilder],
    classOf[Table.Operators],
    classOf[TableSyntax],
    classOf[TableImplicits],
    classOf[While],
    classOf[ForEach],
    classOf[Rule],
    classOf[Condition],
    classOf[Otherwise],
    classOf[RuleBuilder],
    classOf[ConditionBuilder],
    syntax.getClass,
    classOf[syntax.OrderingOperator],
    classOf[syntax.empty],
    classOf[syntax.any],
    classOf[syntax.eqv[_]],
    classOf[syntax.gt[_]],
    classOf[syntax.gte[_]],
    classOf[syntax.lt[_]],
    classOf[syntax.lte[_]],
    classOf[syntax.nonEmpty],
    classOf[syntax.neq[_]],
    classOf[syntax.OperatorOps],
    classOf[implicits.NamingActionRef],
    classOf[implicits.NamingActionDef],
    classOf[implicits.NamingExpression[_]],
    classOf[implicits.CallableActionOps],
    classOf[PythonOperatorSyntax],
    classOf[PythonOperatorOp[_, _]],
    classOf[PythonOperator[_, _]],
    classOf[PyDataCodecImplicits],
    classOf[PyDataEncoder[_]],
    classOf[PyDataDecoder[_]],
    classOf[PyDataCodec[_]],
    classOf[implicits.ToStringEncoder[_]],
    classOf[implicits.BaseDecoder[_]]
  ).map(_.getName).toSet

  def nonEmbeddedClass(className: String): Boolean =
    !ClassNames.contains(className) && !ClassNames.exists(className.startsWith)
}
