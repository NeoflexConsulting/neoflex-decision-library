package ru.neoflex.ndk.dsl.declaration

import ru.neoflex.ndk.dsl.Gateway.{ SealedWhens, When, WhenBuilder }
import ru.neoflex.ndk.dsl.Rule.{ Condition, ConditionBuilder, Otherwise, RuleBuilder }
import ru.neoflex.ndk.dsl._

object NdkInternals {
  val ClassNames: Set[String] = Seq
    .newBuilder[Class[_]]
    .addOne(classOf[Action])
    .addOne(classOf[ActionBase])
    .addOne(classOf[ActionSyntax])
    .addOne(classOf[SealedAction])
    .addOne(classOf[DeclarationLocation])
    .addOne(DeclarationLocation.getClass)
    .addOne(classOf[DeclarationLocationSupport])
    .addOne(NdkInternals.getClass)
    .addOne(classOf[Constants])
    .addOne(classOf[FlowOp])
    .addOne(classOf[RuleOp])
    .addOne(classOf[Flow])
    .addOne(classOf[SealedFlow])
    .addOne(classOf[TableOp])
    .addOne(classOf[GatewayOp])
    .addOne(classOf[WhileOp])
    .addOne(classOf[ForEachOp])
    .addOne(classOf[FlowSyntax])
    .addOne(classOf[Gateway])
    .addOne(classOf[When])
    .addOne(classOf[SealedWhens])
    .addOne(classOf[WhenBuilder])
    .addOne(classOf[GatewaySyntax])
    .addOne(classOf[ImplicitConversions])
    .addOne(implicits.getClass)
    .addOne(classOf[Table])
    .addOne(classOf[Table.TableBuilder])
    .addOne(classOf[Table.Expression])
    .addOne(classOf[Table.ActionDef])
    .addOne(classOf[Table.Condition])
    .addOne(classOf[SealedTable])
    .addOne(classOf[Table.Action0])
    .addOne(classOf[Table.Action1])
    .addOne(classOf[Table.Action2])
    .addOne(classOf[Table.Action3])
    .addOne(classOf[Table.Action4])
    .addOne(classOf[Table.Action5])
    .addOne(classOf[Table.Action6])
    .addOne(classOf[Table.Action7])
    .addOne(classOf[Table.Action8])
    .addOne(classOf[Table.Action9])
    .addOne(classOf[Table.Action10])
    .addOne(classOf[Table.Args])
    .addOne(classOf[Table.CallableAction])
    .addOne(classOf[Table.ActionRef])
    .addOne(classOf[Table.SealedAction])
    .addOne(classOf[Table.Operator])
    .addOne(classOf[Table.RowBuilder])
    .addOne(classOf[Table.Operators])
    .addOne(classOf[TableSyntax])
    .addOne(classOf[TableImplicits])
    .addOne(classOf[While])
    .addOne(classOf[ForEach])
    .addOne(classOf[Rule])
    .addOne(classOf[Condition])
    .addOne(classOf[Otherwise])
    .addOne(classOf[RuleBuilder])
    .addOne(classOf[ConditionBuilder])
    .addOne(syntax.getClass)
    .addOne(classOf[syntax.OrderingOperator])
    .addOne(classOf[syntax.empty])
    .addOne(classOf[syntax.any])
    .addOne(classOf[syntax.eqv[_]])
    .addOne(classOf[syntax.gt[_]])
    .addOne(classOf[syntax.gte[_]])
    .addOne(classOf[syntax.lt[_]])
    .addOne(classOf[syntax.lte[_]])
    .addOne(classOf[syntax.nonEmpty])
    .addOne(classOf[syntax.neq[_]])
    .addOne(classOf[syntax.OperatorOps])
    .addOne(classOf[implicits.NamingActionRef])
    .addOne(classOf[implicits.NamingActionDef])
    .addOne(classOf[implicits.NamingExpression[_]])
    .addOne(classOf[implicits.CallableActionOps])
    .addOne(classOf[PythonOperatorSyntax])
    .addOne(classOf[PythonOperatorOp[_, _]])
    .addOne(classOf[PythonOperator[_, _]])
    .addOne(classOf[PyDataCodecImplicits])
    .addOne(classOf[PyDataEncoder[_]])
    .addOne(classOf[PyDataDecoder[_]])
    .addOne(classOf[PyDataCodec[_]])
    .addOne(classOf[implicits.ToStringEncoder[_]])
    .addOne(classOf[implicits.BaseDecoder[_]])
    .addOne(classOf[RestService[_, _]])
    .addOne(RestService.getClass)
    .addOne(classOf[RestServiceImpl[_, _]])
    .addOne(RestServiceImplicits.getClass)
    .addOne(classOf[RestServiceSyntax])
    .addOne(classOf[MlFlowModelData[_]])
    .addOne(MlFlowModelData.getClass)
    .result()
    .map(_.getName)
    .toSet

  def nonEmbeddedClass(className: String): Boolean =
    !ClassNames.contains(className) && !ClassNames.exists(className.startsWith)
}
